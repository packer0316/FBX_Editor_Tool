// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      properties: &props
        mainTexture:        { value: grey }
        lightBodyTexture:   { value: grey }      # å‘¼å¸ç‡ˆèº«é«”ç™¼å…‰è²¼åœ–
        brushMaskTexture:   { value: grey }      # åˆ·å…‰é®ç½©è²¼åœ–
        brushLightTexture:  { value: grey }      # åˆ·å…‰æ¼¸å±¤è²¼åœ–
        normalMapTexture:   { value: normal }    # æ³•ç·šè²¼åœ–
        matcapBodyTexture:  { value: grey }      # Matcap èº«é«”åå°„è²¼åœ–
        matcapGoldTexture:  { value: grey }      # Matcap é‡‘å±¬å…‰æ¾¤è²¼åœ–
        matcapSuperGoldTexture: { value: grey }  # Matcap ç‰¹é‡‘å±¬å…‰æ¾¤è²¼åœ–
        matcapMaskTexture:  { value: grey }      # Matcap ç ´å£éƒ¨ä½é®ç½©è²¼åœ–
        breathMixMaskTexture: { value: grey }    # å‘¼å¸ç‡ˆæ··åˆé®ç½©è²¼åœ–
        superGoldMaskTexture: { value: grey }    # ç‰¹é‡‘å±¬å…‰æ¾¤é®ç½©è²¼åœ–
        
        # åŸºç¤é¡è‰²
        mainColor:          { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        multColor:          { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        bleachColor:        { value: [1, 1, 1, 0], linear: true, editor: { type: color, parent: USE_BLEACH_COLOR } }
        
        # å‘¼å¸ç‡ˆæ··åˆ
        mixBrightnessFactor: { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        
        # åˆ·å…‰åƒæ•¸
        maskWeight:         { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        maskWeight2:        { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        lightRangBrush:     { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        lightSpeed:         { value: 1.0, range: [0.0, 5.0], editor: { type: slider } }
        
        # ç ´å£éƒ¨ä½
        breakPartNum:       { value: 0.0, range: [0.0, 4.0], editor: { type: slider } }
        
        # Matcap å¼·åº¦
        matcapBodyStrength: { value: 0.5, range: [0.0, 1.0], editor: { type: slider } }
        matcapGoldStrength: { value: 1.0, range: [0.0, 1.0], editor: { type: slider } }
        matcapSuperGoldStrength: { value: 1.0, range: [0.0, 1.0], editor: { type: slider } }
        
        # æ³•ç·šå¼·åº¦
        normalStrength:     { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        normalStrengthWeak: { value: 0.1, range: [0.0, 1.0], editor: { type: slider } }
        
        tilingOffset:       { value: [1, 1, 0, 0] }
        alphaThreshold:     { value: 0.5, editor: { parent: USE_ALPHA_TEST } }
    - &shadow-caster
      vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-caster
      propertyIndex: 0
      rasterizerState:
        cullMode: front
      properties:
        tilingOffset:       { value: [1, 1, 0, 0] }
        mainColor:          { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        alphaThreshold:     { value: 0.5, editor: { parent: USE_ALPHA_TEST } }
        mainTexture:        { value: grey }
        
  - name: transparent
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%


CCProgram unlit-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>

  #if USE_VERTEX_COLOR
    in lowp vec4 a_color;
    out lowp vec4 v_color;
  #endif

  out vec2 v_uv;
  out vec3 v_worldNormal;
  out vec3 v_worldPos;
  out vec3 v_viewNormal;
  out mediump vec4 v_tangent;

  uniform TexCoords {
    vec4 tilingOffset;
  };

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);
    
    // ä¸–ç•Œç©ºé–“æ³•ç·šèˆ‡ä½ç½®
    v_worldNormal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    v_worldPos = (matWorld * In.position).xyz;
    
    // è¦–åœ–ç©ºé–“æ³•ç·šï¼ˆç”¨æ–¼ Matcapï¼‰
    v_viewNormal = normalize(mat3(cc_matView) * v_worldNormal);
    
    // åˆ‡ç·šç©ºé–“
    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    v_tangent.w = In.tangent.w;

    // UV åº§æ¨™
    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif

    #if USE_VERTEX_COLOR
      v_color = a_color;
    #endif

    return cc_matProj * (cc_matView * matWorld) * In.position;
  }
}%


CCProgram unlit-fs %{
  precision highp float;
  #include <legacy/output-standard>
  #include <builtin/uniforms/cc-global>

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r, g, b])
  #endif

  in vec2 v_uv;
  in vec3 v_worldNormal;
  in vec3 v_worldPos;
  in vec3 v_viewNormal;
  in mediump vec4 v_tangent;

  uniform sampler2D mainTexture;
  uniform sampler2D lightBodyTexture;
  uniform sampler2D brushMaskTexture;
  uniform sampler2D brushLightTexture;
  uniform sampler2D normalMapTexture;
  uniform sampler2D matcapBodyTexture;
  uniform sampler2D matcapGoldTexture;
  uniform sampler2D matcapSuperGoldTexture;
  uniform sampler2D matcapMaskTexture;
  uniform sampler2D breathMixMaskTexture;
  uniform sampler2D superGoldMaskTexture;

  uniform Constant {
    vec4 mainColor;
    vec4 multColor;
    float mixBrightnessFactor;
    float maskWeight;
    float maskWeight2;
    float lightRangBrush;
    float lightSpeed;
    float breakPartNum;
    float matcapBodyStrength;
    float matcapGoldStrength;
    float matcapSuperGoldStrength;
    float normalStrength;
    float normalStrengthWeak;
    float alphaThreshold;
  };

  #if USE_BLEACH_COLOR
    uniform BleachValue {
      vec4 bleachColor;
    };
  #endif

  #if USE_VERTEX_COLOR
    in lowp vec4 v_color;
  #endif

  // ============================================================
  // ğŸ†• Bleach é‚Šç·£æ³›å…‰å‡½æ•¸ï¼ˆè²æ¶…çˆ¾æ•ˆæœï¼‰
  // ============================================================
  #if USE_BLEACH_COLOR
    vec3 bleach(vec3 oldColor, float lerpValue, vec3 normal) {
      vec3 worldNor = normalize(normal);
      vec3 viewDir = normalize(cc_cameraPos.xyz - v_worldPos);
      
      // è¨ˆç®—è¦–è§’èˆ‡æ³•ç·šçš„å¤¾è§’ï¼Œé‚Šç·£è™• theta æ¥è¿‘ 1
      float theta = 1.0 - clamp(dot(worldNor, viewDir), 0.0, 1.0);
      
      // æ³›å…‰äº®åº¦å¢å¼·ä¿‚æ•¸
      float scalar = 1.7;
      
      // ä½¿ç”¨ pow è®“é‚Šç·£æ•ˆæœæ›´é›†ä¸­ï¼ˆæŒ‡æ•¸è¶Šå¤§ï¼Œé‚Šç·£è¶ŠéŠ³åˆ©ï¼‰
      float edgeFactor = pow(theta, 2.7);
      
      // æ··åˆåŸè‰²èˆ‡æ³›å…‰è‰²
      return mix(oldColor, bleachColor.rgb * scalar, lerpValue * edgeFactor);
    }
  #endif

  // ============================================================
  // å‘¼å¸ç‡ˆèˆ‡åˆ·å…‰æ··åˆæ•ˆæœ
  // ============================================================
  vec4 BreathBrushColor() {
    // å¾å‘¼å¸ç‡ˆæ··åˆé®ç½©ç²å–é®ç½©å€¼
    vec4 maskColor_mix = texture(breathMixMaskTexture, v_uv);
    float maskValue_mix = maskColor_mix.r;
    
    // å¾ä¸»è¦ç´‹ç†å’Œç™¼å…‰ç´‹ç†ç²å–é¡è‰²
    vec4 texture_og = texture(mainTexture, v_uv);
    texture_og.rgb = SRGBToLinear(texture_og.rgb);

    vec4 texture_lightBody = texture(lightBodyTexture, v_uv);
    texture_lightBody.rgb = SRGBToLinear(texture_lightBody.rgb);

    texture_lightBody *= mixBrightnessFactor;

    // ä½¿ç”¨é®ç½©å€¼æ±ºå®šæ··åˆå¼·åº¦
    vec4 blendedColor = vec4(texture_og.rgb + texture_lightBody.rgb * maskValue_mix, texture_og.a);

    return blendedColor;
  }

  // ============================================================
  // åˆ·å…‰æ•ˆæœï¼ˆå‹•æ…‹å…‰ç·šæƒéï¼‰
  // ============================================================
  vec4 BrushColor(vec4 tempColor, float maskColor_break) {
    vec4 addColor = vec4(1.0) - mainColor;
    vec4 textureColor = tempColor * multColor + addColor;
    
    // å¾åˆ·å…‰é®ç½©ç´‹ç†ç²å–é®ç½©
    vec3 maskColor = texture(brushMaskTexture, v_uv).rgb;
    maskColor *= maskColor_break;

    float t = mod(cc_time.x * lightSpeed, 1.0);
    float offset = abs(mod(maskColor.g - t, 1.0));
    vec2 loghtOffsetCoord = vec2(0.5, offset * lightRangBrush);
    
    // å¾åˆ·å…‰æ¼¸å±¤ç´‹ç†ç²å–å…‰ç·šé¡è‰²
    float lightColor = texture(brushLightTexture, loghtOffsetCoord).r;
    
    float maskAdd = 1.0 + maskWeight * maskWeight2 * maskColor.r + maskWeight * maskColor.b * lightColor;

    vec4 finalColor = textureColor * maskAdd + addColor;
    finalColor.a = textureColor.a;
    return finalColor;
  }

  // ============================================================
  // æ³•ç·šè²¼åœ–è™•ç†ï¼ˆè¿”å›è™•ç†å¾Œçš„ä¸–ç•Œç©ºé–“æ³•ç·šï¼‰
  // ============================================================
  vec3 GetNormalFromMap(float tuneStrength) {
    vec3 nmmp = texture(normalMapTexture, v_uv).xyz - vec3(0.5);

    vec3 tangent = normalize(v_tangent.xyz);
    vec3 bitangent = cross(v_worldNormal, tangent);
    
    vec3 normal = 
        (nmmp.x * tuneStrength) * tangent + 
        (nmmp.y * tuneStrength) * normalize(bitangent) + 
        nmmp.z * normalize(v_worldNormal);

    return normalize(normal);
  }

  // ============================================================
  // è¨ˆç®— Matcap UVï¼ˆå¾ä¸–ç•Œç©ºé–“æ³•ç·šè½‰æ›åˆ°è¦–åœ–ç©ºé–“ï¼‰
  // ============================================================
  vec2 GetMatcapUV(vec3 worldNormal) {
    // å°‡ä¸–ç•Œç©ºé–“æ³•ç·šè½‰æ›åˆ°è¦–åœ–ç©ºé–“
    vec3 viewNormal = normalize(mat3(cc_matView) * worldNormal);
    vec2 muv = viewNormal.xy * 0.5 + 0.5;
    return muv;
  }

  // ============================================================
  // MatCap é‡‘å±¬åå°„æ•ˆæœ
  // ============================================================
  vec3 MatCapEffect(vec2 muv, sampler2D matcapTex, float strength) {
    vec4 matcapColor = texture(matcapTex, muv);
    matcapColor.rgb = SRGBToLinear(matcapColor.rgb);
    vec3 metalEffect = matcapColor.rgb * strength;
    return metalEffect;
  }

  // ============================================================
  // é¡è‰²æ¨™æº–åŒ–
  // ============================================================
  vec4 ColorStandardization(vec4 tempColor) { 
    vec4 addColor = vec4(1.0) - mainColor;
    vec4 rtColor = tempColor * multColor + addColor;
    rtColor = clamp(rtColor, 0.0, 1.0);
    return rtColor;
  }

  vec4 frag () {
    // ============================================================
    // æ­¥é©Ÿ 1: åˆ¤æ–·æ˜¯å¦éœ€è¦ä½¿ç”¨å‘¼å¸åˆ·å…‰
    // ============================================================
    vec4 finalColor = texture(mainTexture, v_uv);
    finalColor.rgb = SRGBToLinear(finalColor.rgb);
    
    if (breakPartNum >= 3.0) {
      finalColor = BreathBrushColor();
    }

    // ============================================================
    // æ­¥é©Ÿ 2: åˆ¤æ–·ç ´å£çš„éƒ¨ä½çš„ matcap é®ç½©
    // ============================================================
    float maskColor_break = 0.0;
    vec4 matcapMask = texture(matcapMaskTexture, v_uv);
    
    if (breakPartNum == 0.0) {
      maskColor_break = matcapMask.g;
    } else if (breakPartNum == 1.0) {
      maskColor_break = matcapMask.r + matcapMask.g;
    } else if (breakPartNum >= 2.0) {
      maskColor_break = matcapMask.r + matcapMask.g + matcapMask.b;
    }

    // ============================================================
    // æ­¥é©Ÿ 3: åˆ¤æ–·æ˜¯å¦éœ€è¦é™ä½ normalMap çš„å¼·åº¦
    // ============================================================
    float tuneStrength = normalStrength;
    if (matcapMask.g > 0.0) {
      tuneStrength = normalStrengthWeak;
    }

    // ============================================================
    // æ­¥é©Ÿ 4: normalMap è™•ç†
    // ============================================================
    vec3 finalNormal = GetNormalFromMap(tuneStrength);
    
    // è¨ˆç®— Matcap UV
    vec2 matcap_uv = GetMatcapUV(finalNormal);
    vec2 matcap_uv_flipped = vec2(matcap_uv.x, 1.0 - matcap_uv.y);

    // ============================================================
    // æ­¥é©Ÿ 5: matCap body (èº«é«”åŸºç¤é‡‘å±¬åå°„)
    // ============================================================
    vec3 metalEffect = MatCapEffect(matcap_uv_flipped, matcapBodyTexture, matcapBodyStrength);
    finalColor = vec4(finalColor.rgb + metalEffect, 1.0);

    // ============================================================
    // æ­¥é©Ÿ 6: matCap metal gold (é‡‘å±¬å…‰æ¾¤)
    // ============================================================
    vec3 goldEffect = MatCapEffect(matcap_uv_flipped, matcapGoldTexture, matcapGoldStrength);
    finalColor = vec4(finalColor.rgb * (1.0 - maskColor_break) + goldEffect * maskColor_break, finalColor.a);

    // ============================================================
    // æ­¥é©Ÿ 7: matCap super gold (ç‰¹é‡‘å±¬å…‰æ¾¤)
    // ============================================================
    vec3 superGoldEffect = MatCapEffect(matcap_uv_flipped, matcapSuperGoldTexture, matcapSuperGoldStrength);

    float superGoldMask = texture(superGoldMaskTexture, v_uv).r;
    finalColor = vec4(finalColor.rgb * (1.0 - superGoldMask) + superGoldEffect * superGoldMask, finalColor.a);

    // ============================================================
    // æ­¥é©Ÿ 8: åˆ·å…‰ï¼ˆç™½å…‰ï¼‰
    // ============================================================
    finalColor = BrushColor(finalColor, maskColor_break);

    // ============================================================
    // æ­¥é©Ÿ 9: æœ€çµ‚è™•ç†
    // ============================================================
    finalColor = ColorStandardization(finalColor);
    finalColor.a = mainColor.a;

    // ============================================================
    // ğŸ†• æ­¥é©Ÿ 10: Bleach é‚Šç·£æ³›å…‰æ•ˆæœ
    // ============================================================
    #if USE_BLEACH_COLOR
      // åªæœ‰ç•¶ bleachColor.w (alpha) > 0 æ™‚æ‰å¥—ç”¨é‚Šç·£æ³›å…‰
      if (bleachColor.w > 0.0) {
          finalColor.rgb = bleach(finalColor.rgb, bleachColor.w, finalNormal);
      }
    #endif

    #if USE_VERTEX_COLOR
      finalColor.rgb *= SRGBToLinear(v_color.rgb);
      finalColor.a *= v_color.a;
    #endif

    #if USE_ALPHA_TEST
      if (finalColor.ALPHA_TEST_CHANNEL < alphaThreshold) discard;
    #endif

    return CCFragOutput(finalColor);
  }
}%


CCProgram shadow-caster-vs %{
  precision highp float;
  #include <legacy/input>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <builtin/uniforms/cc-shadow>

  #if USE_TEXTURE
    out vec2 v_uv;
    uniform TexCoords {
      vec4 tilingOffset;
    };
  #endif
  out vec4 v_worldPos;
  out highp vec2 v_clip_depth;

  vec4 vert () {
    vec4 position;
    CCVertInput(position);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    v_worldPos = matWorld * position;
    vec4 clipPos = cc_matLightViewProj * v_worldPos;

    #if USE_TEXTURE
      v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
      #if SAMPLE_FROM_RT
        CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
      #endif
    #endif

    v_clip_depth = clipPos.zw;

    return clipPos;
  }
}%


CCProgram shadow-caster-fs %{
  precision highp float;
  #include <legacy/output-standard>
  #include <common/data/packing>
  #include <legacy/shadow-map-base>

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r, g, b])
  #endif

  #if USE_TEXTURE
    in vec2 v_uv;
    uniform sampler2D mainTexture;
  #endif
  in vec4 v_worldPos;
  in highp vec2 v_clip_depth;

  uniform Constant {
    vec4 mainColor;
    float alphaThreshold;
  };

  vec4 frag () {
    vec4 o = mainColor;

    #if USE_ALPHA_TEST
      #if USE_TEXTURE
        o *= texture(mainTexture, v_uv);
      #endif
      if (o.ALPHA_TEST_CHANNEL < alphaThreshold) discard;
    #endif

    highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;
    if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {
      #if CC_SHADOWMAP_USE_LINEAR_DEPTH
        clipDepth = CCGetLinearDepth(v_worldPos.xyz);
      #endif
    }

    #if CC_SHADOWMAP_FORMAT == SHADOWMAP_FORMAT_RGBA8
      return packDepthToRGBA(clipDepth);
    #else
      return vec4(clipDepth, 1.0, 1.0, 1.0);
    #endif
  }
}%