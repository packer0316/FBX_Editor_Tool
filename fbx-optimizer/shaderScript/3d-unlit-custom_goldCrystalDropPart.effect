// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      properties: &props
        mainTexture:        { value: grey }
        lightBodyTexture:   { value: grey }
        brushMaskTexture:   { value: grey }
        brushLightTexture:  { value: grey }
        normalMapTexture:   { value: normal }
        matcapBodyTexture:  { value: grey }
        matcapGoldTexture:  { value: grey }
        matcapSuperGoldTexture: { value: grey }
        matcapMaskTexture:  { value: grey }
        breathMixMaskTexture: { value: grey }
        superGoldMaskTexture: { value: grey }
        dissolveNoiseTexture: { value: grey }
        
        mainColor:          { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        multColor:          { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        bleachColor:        { value: [1, 1, 1, 0], linear: true, editor: { type: color, parent: USE_BLEACH_COLOR } }
        
        mixBrightnessFactor: { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        
        maskWeight:         { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        maskWeight2:        { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        lightRangBrush:     { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        lightSpeed:         { value: 1.0, range: [0.0, 5.0], editor: { type: slider } }
        
        breakPartNum:       { value: 0.0, range: [0.0, 4.0], editor: { type: slider } }
        
        matcapBodyStrength: { value: 0.5, range: [0.0, 1.0], editor: { type: slider } }
        matcapGoldStrength: { value: 1.0, range: [0.0, 1.0], editor: { type: slider } }
        matcapSuperGoldStrength: { value: 1.0, range: [0.0, 1.0], editor: { type: slider } }
        
        normalStrength:     { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        normalStrengthWeak: { value: 0.1, range: [0.0, 1.0], editor: { type: slider } }
        
        dissolveAmount:     { value: 0.0, range: [0.0, 1.0], editor: { type: slider, parent: USE_DISSOLVE } }
        dissolveEdgeWidth:  { value: 0.1, range: [0.0, 0.5], editor: { type: slider, parent: USE_DISSOLVE } }
        dissolveEdgeColor:  { value: [1, 0.5, 0, 1], linear: true, editor: { type: color, parent: USE_DISSOLVE } }
        dissolveNoiseScale: { value: 1.0, range: [0.1, 5.0], editor: { type: slider, parent: USE_DISSOLVE } }
        
        tilingOffset:       { value: [1, 1, 0, 0] }
        alphaThreshold:     { value: 0.5, editor: { parent: USE_ALPHA_TEST } }
    - &shadow-caster
      vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-caster
      propertyIndex: 0
      rasterizerState:
        cullMode: front
      properties:
        tilingOffset:       { value: [1, 1, 0, 0] }
        mainColor:          { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        alphaThreshold:     { value: 0.5, editor: { parent: USE_ALPHA_TEST } }
        mainTexture:        { value: grey }
        dissolveNoiseTexture: { value: grey, editor: { parent: USE_DISSOLVE } }
        dissolveAmount:     { value: 0.0, range: [0.0, 1.0], editor: { parent: USE_DISSOLVE } }
        dissolveNoiseScale: { value: 1.0, range: [0.1, 5.0], editor: { parent: USE_DISSOLVE } }
        
  - name: transparent
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%


CCProgram unlit-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>

  #if USE_VERTEX_COLOR
    in lowp vec4 a_color;
    out lowp vec4 v_color;
  #endif

  out vec2 v_uv;
  out vec3 v_worldNormal;
  out vec3 v_worldPos;
  out vec3 v_viewNormal;
  out mediump vec4 v_tangent;

  uniform TexCoords {
    vec4 tilingOffset;
  };

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);
    
    v_worldNormal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    v_worldPos = (matWorld * In.position).xyz;
    
    v_viewNormal = normalize(mat3(cc_matView) * v_worldNormal);
    
    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    v_tangent.w = In.tangent.w;

    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif

    #if USE_VERTEX_COLOR
      v_color = a_color;
    #endif

    return cc_matProj * (cc_matView * matWorld) * In.position;
  }
}%


CCProgram unlit-fs %{
  precision highp float;
  #include <legacy/output-standard>
  #include <builtin/uniforms/cc-global>

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r, g, b])
  #endif

  in vec2 v_uv;
  in vec3 v_worldNormal;
  in vec3 v_worldPos;
  in vec3 v_viewNormal;
  in mediump vec4 v_tangent;

  uniform sampler2D mainTexture;
  uniform sampler2D lightBodyTexture;
  uniform sampler2D brushMaskTexture;
  uniform sampler2D brushLightTexture;
  uniform sampler2D normalMapTexture;
  uniform sampler2D matcapBodyTexture;
  uniform sampler2D matcapGoldTexture;
  uniform sampler2D matcapSuperGoldTexture;
  uniform sampler2D matcapMaskTexture;
  uniform sampler2D breathMixMaskTexture;
  uniform sampler2D superGoldMaskTexture;
  
  #if USE_DISSOLVE
    uniform sampler2D dissolveNoiseTexture;
  #endif

  uniform Constant {
    vec4 mainColor;
    vec4 multColor;
    float mixBrightnessFactor;
    float maskWeight;
    float maskWeight2;
    float lightRangBrush;
    float lightSpeed;
    float breakPartNum;
    float matcapBodyStrength;
    float matcapGoldStrength;
    float matcapSuperGoldStrength;
    float normalStrength;
    float normalStrengthWeak;
    float alphaThreshold;
  };

  #if USE_BLEACH_COLOR
    uniform BleachValue {
      vec4 bleachColor;
    };
  #endif

  #if USE_DISSOLVE
    uniform DissolveValue {
      vec4 dissolveEdgeColor;
      float dissolveAmount;
      float dissolveEdgeWidth;
      float dissolveNoiseScale;
    };
  #endif

  #if USE_VERTEX_COLOR
    in lowp vec4 v_color;
  #endif

  #if USE_BLEACH_COLOR
    vec3 bleach(vec3 oldColor, float lerpValue, vec3 normal) {
      vec3 worldNor = normalize(normal);
      vec3 viewDir = normalize(cc_cameraPos.xyz - v_worldPos);
      
      float theta = 1.0 - clamp(dot(worldNor, viewDir), 0.0, 1.0);
      float scalar = 1.7;
      float edgeFactor = pow(theta, 2.7);
      
      return mix(oldColor, bleachColor.rgb * scalar, lerpValue * edgeFactor);
    }
  #endif

  vec4 BreathBrushColor() {
    vec4 maskColor_mix = texture(breathMixMaskTexture, v_uv);
    float maskValue_mix = maskColor_mix.r;
    
    vec4 texture_og = texture(mainTexture, v_uv);
    texture_og.rgb = SRGBToLinear(texture_og.rgb);

    vec4 texture_lightBody = texture(lightBodyTexture, v_uv);
    texture_lightBody.rgb = SRGBToLinear(texture_lightBody.rgb);

    texture_lightBody *= mixBrightnessFactor;

    vec4 blendedColor = vec4(texture_og.rgb + texture_lightBody.rgb * maskValue_mix, texture_og.a);

    return blendedColor;
  }

  vec4 BrushColor(vec4 tempColor, float maskColor_break) {
    vec4 addColor = vec4(1.0) - mainColor;
    vec4 textureColor = tempColor * multColor + addColor;
    
    vec3 maskColor = texture(brushMaskTexture, v_uv).rgb;
    maskColor *= maskColor_break;

    float t = mod(cc_time.x * lightSpeed, 1.0);
    float offset = abs(mod(maskColor.g - t, 1.0));
    vec2 loghtOffsetCoord = vec2(0.5, offset * lightRangBrush);
    
    float lightColor = texture(brushLightTexture, loghtOffsetCoord).r;
    
    float maskAdd = 1.0 + maskWeight * maskWeight2 * maskColor.r + maskWeight * maskColor.b * lightColor;

    vec4 finalColor = textureColor * maskAdd + addColor;
    finalColor.a = textureColor.a;
    return finalColor;
  }

  vec3 GetNormalFromMap(float tuneStrength) {
    vec3 nmmp = texture(normalMapTexture, v_uv).xyz - vec3(0.5);

    vec3 tangent = normalize(v_tangent.xyz);
    vec3 bitangent = cross(v_worldNormal, tangent);
    
    vec3 normal = 
        (nmmp.x * tuneStrength) * tangent + 
        (nmmp.y * tuneStrength) * normalize(bitangent) + 
        nmmp.z * normalize(v_worldNormal);

    return normalize(normal);
  }

  vec2 GetMatcapUV(vec3 worldNormal) {
    vec3 viewNormal = normalize(mat3(cc_matView) * worldNormal);
    vec2 muv = viewNormal.xy * 0.5 + 0.5;
    return muv;
  }

  vec3 MatCapEffect(vec2 muv, sampler2D matcapTex, float strength) {
    vec4 matcapColor = texture(matcapTex, muv);
    matcapColor.rgb = SRGBToLinear(matcapColor.rgb);
    vec3 metalEffect = matcapColor.rgb * strength;
    return metalEffect;
  }

  vec4 ColorStandardization(vec4 tempColor) { 
    vec4 addColor = vec4(1.0) - mainColor;
    vec4 rtColor = tempColor * multColor + addColor;
    rtColor = clamp(rtColor, 0.0, 1.0);
    return rtColor;
  }

  vec4 frag () {
    #if USE_DISSOLVE
      float noise = texture(dissolveNoiseTexture, v_uv * dissolveNoiseScale).r;
      
      float dissolveThreshold = dissolveAmount;
      
      if (noise < dissolveThreshold) {
        discard;
      }
      
      float edgeStart = dissolveThreshold;
      float edgeEnd = dissolveThreshold + dissolveEdgeWidth;
      float edgeFactor = 0.0;
      
      if (noise < edgeEnd) {
        edgeFactor = 1.0 - smoothstep(edgeStart, edgeEnd, noise);
      }
    #endif

    vec4 finalColor = texture(mainTexture, v_uv);
    finalColor.rgb = SRGBToLinear(finalColor.rgb);
    
    if (breakPartNum >= 3.0) {
      finalColor = BreathBrushColor();
    }

    float maskColor_break = 0.0;
    vec4 matcapMask = texture(matcapMaskTexture, v_uv);
    
    if (breakPartNum == 0.0) {
      maskColor_break = matcapMask.g;
    } else if (breakPartNum == 1.0) {
      maskColor_break = matcapMask.r + matcapMask.g;
    } else if (breakPartNum >= 2.0) {
      maskColor_break = matcapMask.r + matcapMask.g + matcapMask.b;
    }

    float tuneStrength = normalStrength;
    if (matcapMask.g > 0.0) {
      tuneStrength = normalStrengthWeak;
    }

    vec3 finalNormal = GetNormalFromMap(tuneStrength);
    
    vec2 matcap_uv = GetMatcapUV(finalNormal);
    vec2 matcap_uv_flipped = vec2(matcap_uv.x, 1.0 - matcap_uv.y);

    vec3 metalEffect = MatCapEffect(matcap_uv_flipped, matcapBodyTexture, matcapBodyStrength);
    finalColor = vec4(finalColor.rgb + metalEffect, 1.0);

    vec3 goldEffect = MatCapEffect(matcap_uv_flipped, matcapGoldTexture, matcapGoldStrength);
    finalColor = vec4(finalColor.rgb * (1.0 - maskColor_break) + goldEffect * maskColor_break, finalColor.a);

    vec3 superGoldEffect = MatCapEffect(matcap_uv_flipped, matcapSuperGoldTexture, matcapSuperGoldStrength);

    float superGoldMask = texture(superGoldMaskTexture, v_uv).r;
    finalColor = vec4(finalColor.rgb * (1.0 - superGoldMask) + superGoldEffect * superGoldMask, finalColor.a);

    finalColor = BrushColor(finalColor, maskColor_break);

    finalColor = ColorStandardization(finalColor);
    finalColor.a = mainColor.a;

    #if USE_DISSOLVE
      if (edgeFactor > 0.0) {
        finalColor.rgb = mix(finalColor.rgb, dissolveEdgeColor.rgb, edgeFactor * dissolveEdgeColor.a);
      }
    #endif

    #if USE_BLEACH_COLOR
      if (bleachColor.w > 0.0) {
          finalColor.rgb = bleach(finalColor.rgb, bleachColor.w, finalNormal);
      }
    #endif

    #if USE_VERTEX_COLOR
      finalColor.rgb *= SRGBToLinear(v_color.rgb);
      finalColor.a *= v_color.a;
    #endif

    #if USE_ALPHA_TEST
      if (finalColor.ALPHA_TEST_CHANNEL < alphaThreshold) discard;
    #endif

    return CCFragOutput(finalColor);
  }
}%


CCProgram shadow-caster-vs %{
  precision highp float;
  #include <legacy/input>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <builtin/uniforms/cc-shadow>

  #if USE_TEXTURE || USE_DISSOLVE
    out vec2 v_uv;
    uniform TexCoords {
      vec4 tilingOffset;
    };
  #endif
  out vec4 v_worldPos;
  out highp vec2 v_clip_depth;

  vec4 vert () {
    vec4 position;
    CCVertInput(position);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    v_worldPos = matWorld * position;
    vec4 clipPos = cc_matLightViewProj * v_worldPos;

    #if USE_TEXTURE || USE_DISSOLVE
      v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
      #if SAMPLE_FROM_RT
        CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
      #endif
    #endif

    v_clip_depth = clipPos.zw;

    return clipPos;
  }
}%


CCProgram shadow-caster-fs %{
  precision highp float;
  #include <legacy/output-standard>
  #include <common/data/packing>
  #include <legacy/shadow-map-base>

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r, g, b])
  #endif

  #if USE_TEXTURE || USE_DISSOLVE
    in vec2 v_uv;
  #endif
  
  #if USE_TEXTURE
    uniform sampler2D mainTexture;
  #endif
  
  #if USE_DISSOLVE
    uniform sampler2D dissolveNoiseTexture;
  #endif
  
  in vec4 v_worldPos;
  in highp vec2 v_clip_depth;

  uniform Constant {
    vec4 mainColor;
    float alphaThreshold;
  };

  #if USE_DISSOLVE
    uniform DissolveValue {
      float dissolveAmount;
      float dissolveNoiseScale;
    };
  #endif

  vec4 frag () {
    #if USE_DISSOLVE
      // üîß ÈóúÈçµ‰øÆÊ≠£Ôºö‰ΩøÁî®Ëàá‰∏ª shader Áõ∏ÂêåÁöÑÂô™ËÅ≤Êé°Ê®£ÊñπÂºè
      float noise = texture(dissolveNoiseTexture, v_uv * dissolveNoiseScale).r;
      if (noise < dissolveAmount) {
        discard;
      }
    #endif

    vec4 o = mainColor;

    #if USE_ALPHA_TEST
      #if USE_TEXTURE
        o *= texture(mainTexture, v_uv);
      #endif
      if (o.ALPHA_TEST_CHANNEL < alphaThreshold) discard;
    #endif

    highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;
    if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {
      #if CC_SHADOWMAP_USE_LINEAR_DEPTH
        clipDepth = CCGetLinearDepth(v_worldPos.xyz);
      #endif
    }

    #if CC_SHADOWMAP_FORMAT == SHADOWMAP_FORMAT_RGBA8
      return packDepthToRGBA(clipDepth);
    #else
      return vec4(clipDepth, 1.0, 1.0, 1.0);
    #endif
  }
}%