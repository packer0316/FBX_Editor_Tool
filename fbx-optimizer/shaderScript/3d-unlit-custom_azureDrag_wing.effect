// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: custom-vs:vert
      frag: custom-fs:frag
      properties: &props
        mainTexture:          { value: grey }
        lightTextureBody:     { value: grey }     # èº«é«”ç™¼å…‰è²¼åœ–
        maskTexture:          { value: grey }     # åˆ·å…‰é®ç½©è²¼åœ–
        lightTexture:         { value: grey }     # åˆ·å…‰æ¼¸å±¤è²¼åœ–
        mouthMaskTexture:     { value: grey }     # å˜´éƒ¨é®ç½©è²¼åœ–
        matcapTexture:        { value: grey }     # Matcap é‡‘å±¬åå°„è²¼åœ–
        normalMap:            { value: normal }   # æ³•ç·šè²¼åœ–
        
        # åŸºç¤é¡è‰²
        mainColor:            { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        multColor:            { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        bleachColor:          { value: [1, 1, 1, 0], linear: true, editor: { type: color, parent: USE_BLEACH_COLOR } } # ğŸ†• é‚Šç·£æ³›å…‰é¡è‰²ï¼ˆalpha æ§åˆ¶å¼·åº¦ï¼‰
        
        # æ··åˆèˆ‡ç™¼å…‰
        mixBrightness:        { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        breathSpeed:          { value: 1.0, range: [0.0, 5.0], editor: { type: slider } }
        breathIntensity:      { value: 0.5, range: [0.0, 1.0], editor: { type: slider } }
        
        # åˆ·å…‰åƒæ•¸
        maskWeight:           { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        maskWeight2:          { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        lightRange:           { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        lightSpeed:           { value: 1.0, range: [0.0, 5.0], editor: { type: slider } }
        reverseLightSweep:    { value: 0.0, editor: { type: toggle } } # ğŸŒŸ ä¿®æ”¹: ä½¿ç”¨ float 0.0/1.0 æ¨¡æ“¬ toggle
        
        # ç°éšèˆ‡å°æ¯”åº¦
        grayScaleFactor:      { value: 0.0, range: [0.0, 1.0], editor: { type: slider } }
        contrast:             { value: 1.0, range: [0.5, 2.0], editor: { type: slider } }
        
        # Matcap èˆ‡æ³•ç·š
        reflectivity:         { value: 0.5, range: [0.0, 1.0], editor: { type: slider } }
        reflectivity2:        { value: 0.5, range: [0.0, 1.0], editor: { type: slider } }
        brightnessFactor:     { value: 1.0, range: [0.0, 2.0], editor: { type: slider } }
        normalStrength:       { value: 1.0, range: [0.0, 5.0], editor: { type: slider } }
        
        tilingOffset:         { value: [1, 1, 0, 0] }
        alphaThreshold:       { value: 0.5, editor: { parent: USE_ALPHA_TEST } }
        
  - name: transparent
    passes:
    - vert: custom-vs:vert
      frag: custom-fs:frag
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%


CCProgram custom-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>

  #if USE_VERTEX_COLOR
    in lowp vec4 a_color;
    out lowp vec4 v_color;
  #endif

  out vec2 v_uv;
  out vec3 v_worldNormal;
  out vec3 v_worldPos;
  out vec3 v_viewNormal;
  out mediump vec4 v_tangent;

  uniform TexCoords {
    vec4 tilingOffset;
  };

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);
    
    // ä¸–ç•Œç©ºé–“æ³•ç·šèˆ‡ä½ç½®
    v_worldNormal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    v_worldPos = (matWorld * In.position).xyz;
    
    // è¦–åœ–ç©ºé–“æ³•ç·šï¼ˆç”¨æ–¼ Matcapï¼‰
    v_viewNormal = normalize(mat3(cc_matView) * v_worldNormal);
    
    // åˆ‡ç·šç©ºé–“
    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    v_tangent.w = In.tangent.w;

    // UV åº§æ¨™
    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif

    #if USE_VERTEX_COLOR
      v_color = a_color;
    #endif

    return cc_matProj * (cc_matView * matWorld) * In.position;
  }
}%


CCProgram custom-fs %{
  precision highp float;
  #include <legacy/output-standard>
  #include <builtin/uniforms/cc-global>

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r, g, b])
  #endif

  in vec2 v_uv;
  in vec3 v_worldNormal;
  in vec3 v_worldPos;
  in vec3 v_viewNormal;
  in mediump vec4 v_tangent;

  uniform sampler2D mainTexture;
  uniform sampler2D lightTextureBody;
  uniform sampler2D maskTexture;
  uniform sampler2D lightTexture;
  uniform sampler2D mouthMaskTexture;
  uniform sampler2D matcapTexture;
  uniform sampler2D normalMap;

  uniform Constant {
    vec4 mainColor;
    vec4 multColor;
    vec4 bleachColor;         // ğŸ†• é‚Šç·£æ³›å…‰é¡è‰²
    float mixBrightness;
    float breathSpeed;
    float breathIntensity;
    float maskWeight;
    float maskWeight2;
    float lightRange;
    float lightSpeed;
    float reverseLightSweep; 
    float grayScaleFactor;
    float contrast;
    float reflectivity;
    float reflectivity2;
    float brightnessFactor;
    float normalStrength;
    float alphaThreshold;
  };

  #if USE_VERTEX_COLOR
    in lowp vec4 v_color;
  #endif
  
  // ğŸ†• Bleach é‚Šç·£æ³›å…‰å‡½æ•¸ï¼ˆè²æ¶…çˆ¾æ•ˆæœï¼‰
  #if USE_BLEACH_COLOR
    vec3 bleach(vec3 oldColor, float lerpValue, vec3 normal) {
      vec3 worldNor = normalize(normal);
      vec3 viewDir = normalize(cc_cameraPos.xyz - v_worldPos);
      
      // è¨ˆç®—è¦–è§’èˆ‡æ³•ç·šçš„å¤¾è§’ï¼Œé‚Šç·£è™• theta æ¥è¿‘ 1
      float theta = 1.0 - clamp(dot(worldNor, viewDir), 0.0, 1.0);
      
      // æ³›å…‰äº®åº¦å¢å¼·ä¿‚æ•¸
      float scalar = 1.7;
      
      // ä½¿ç”¨ pow è®“é‚Šç·£æ•ˆæœæ›´é›†ä¸­ï¼ˆæŒ‡æ•¸è¶Šå¤§ï¼Œé‚Šç·£è¶ŠéŠ³åˆ©ï¼‰
      float edgeFactor = pow(theta, 2.7);
      
      // æ··åˆåŸè‰²èˆ‡æ³›å…‰è‰²
      return mix(oldColor, bleachColor.rgb * scalar, lerpValue * edgeFactor);
    }
  #endif

  vec4 frag () {
    // ============================================================
    // æ­¥é©Ÿ 1: åŸºç¤ç´‹ç†æ··åˆï¼ˆèº«é«”ç™¼å…‰æ•ˆæœ - å‘¼å¸ç‡ˆï¼‰
    // ============================================================
    vec4 maskColor_mix = texture(maskTexture, v_uv);
    float maskValue_mix = maskColor_mix.g + maskColor_mix.b;
    
    // ğŸ”¥ ä¿®æ­£ï¼šåŠ å…¥ sRGB è½‰ç·šæ€§ç©ºé–“
    vec4 texture_og = texture(mainTexture, v_uv);
    texture_og.rgb = SRGBToLinear(texture_og.rgb);
    
    vec4 texture_lightBody = texture(lightTextureBody, v_uv);
    texture_lightBody.rgb = SRGBToLinear(texture_lightBody.rgb);
    
    // ğŸŒŸ æ–°å¢ï¼šå‘¼å¸ç‡ˆæ•ˆæœï¼ˆä½¿ç”¨ sin å‡½æ•¸ç”¢ç”Ÿå¹³æ»‘çš„å¼·å¼±å¾ªç’°ï¼‰
    float breathCycle = sin(cc_time.x * breathSpeed) * 0.5 + 0.5;
    
    float dynamicBrightness = mixBrightness * (1.0 - breathIntensity + breathCycle * breathIntensity * 2.0);
    
    texture_lightBody *= dynamicBrightness;
    
    vec4 blendedColor = mix(texture_og, texture_lightBody, maskValue_mix);
    vec4 tempColor1 = blendedColor;

    // ============================================================
    // æ­¥é©Ÿ 2: åˆ·å…‰æ•ˆæœï¼ˆå‹•æ…‹å…‰ç·šæƒéï¼‰
    // ============================================================
    // ğŸ”¥ ä¿®æ­£ï¼šåªæœ‰ç•¶ mainColor ä¸æ˜¯ç™½è‰²æ™‚æ‰è¨ˆç®— addColor
    vec4 addColor = vec4(1.0) - mainColor;
    vec4 textureColor = tempColor1 * multColor;
    
    // ğŸ”¥ ä¿®æ­£ï¼šåªåœ¨éœ€è¦æ™‚åŠ ä¸Š addColorï¼ˆé¿å…éäº®ï¼‰
    if (mainColor.r < 0.99 || mainColor.g < 0.99 || mainColor.b < 0.99) {
        textureColor += addColor;
    }
    
    vec3 maskColor = texture(maskTexture, v_uv).rgb;

    // ğŸŒŸ ä¿®æ”¹: æ ¹æ“š reverseLightSweep (float) æ±ºå®šæƒå…‰æ–¹å‘
    float time = cc_time.x * lightSpeed;
    float t;
    
    // åˆ¤æ–· float æ˜¯å¦å¤§æ–¼ 0.5 (å³é–‹é—œç‚º ON/1.0)
    if (reverseLightSweep > 0.5) { 
      // é€†å‘åˆ·å…‰
      t = mod(1.0 - time, 1.0);
    } else {
      // æ­£å‘åˆ·å…‰
      t = mod(time, 1.0);
    }
    
    float offset = abs(mod(maskColor.g - t, 1.0));
    float lightColor = texture(lightTexture, vec2(0.5, offset * lightRange)).r;
    
    // ğŸ”¥ ä¿®æ­£ï¼šåˆ·å…‰æ•ˆæœæ”¹ç‚ºåŠ æ³•ï¼Œé¿å…éåº¦ä¹˜ç®—
    float maskAdd = maskWeight * maskWeight2 * maskColor.r + maskWeight * maskColor.b * lightColor;

    vec4 finalColor = textureColor * (1.0 + maskAdd);
    finalColor.a = textureColor.a;

    // ============================================================
    // æ­¥é©Ÿ 3: ç°éšèˆ‡å°æ¯”åº¦èª¿æ•´
    // ============================================================
    float gray = dot(textureColor.rgb, vec3(0.299, 0.587, 0.114));
    vec3 grayColor = vec3(gray);
    vec3 mixedColor = mix(textureColor.rgb, grayColor, grayScaleFactor);

    if (grayScaleFactor > 0.0) {
        mixedColor = ((mixedColor - 0.5) * contrast + 0.5);
    }

    // ğŸ”¥ ä¿®æ­£ï¼šé€™è£¡ä¸è¦å†ç–ŠåŠ  maskAdd å’Œ addColor
    finalColor.rgb = mixedColor * (1.0 + maskAdd);

    // ============================================================
    // æ­¥é©Ÿ 4: æ³•ç·šè²¼åœ–è™•ç†
    // ============================================================
    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);
    vec3 tangent = normalize(v_tangent.xyz);
    vec3 bitangent = cross(v_worldNormal, tangent) * (v_tangent.w > 0.0 ? 1.0 : -1.0);
    
    vec3 normal = 
        (nmmp.x * normalStrength) * tangent + 
        (nmmp.y * normalStrength) * normalize(bitangent) + 
        nmmp.z * normalize(v_worldNormal);
    
    normal = normalize(normal);

    // ============================================================
    // æ­¥é©Ÿ 5: Matcap é‡‘å±¬åå°„æ•ˆæœ
    // ============================================================
    vec3 viewNormal = normalize(mat3(cc_matView) * normal); 
    vec2 muv = viewNormal.xy * 0.5 + 0.5;

    vec4 matcapColor = texture(matcapTexture, vec2(muv.x, 1.0 - muv.y));
    matcapColor.rgb = SRGBToLinear(matcapColor.rgb);
    
    // ğŸ”¥ ä¿®æ­£ï¼šé‡‘å±¬æ•ˆæœæ”¹ç‚ºé©åº¦æ··åˆï¼Œé¿å…éäº®
    vec3 metalEffect = matcapColor.rgb * reflectivity * 0.5;

    // ç–ŠåŠ é‡‘å±¬æ•ˆæœ
    finalColor.rgb = finalColor.rgb + metalEffect;

    // ============================================================
    // ğŸ†• æ­¥é©Ÿ 6: Bleach é‚Šç·£æ³›å…‰æ•ˆæœ
    // ============================================================
    #if USE_BLEACH_COLOR
      // åªæœ‰ç•¶ bleachColor.w (alpha) > 0 æ™‚æ‰å¥—ç”¨é‚Šç·£æ³›å…‰
      if (bleachColor.w > 0.0) {
          finalColor.rgb = bleach(finalColor.rgb, bleachColor.w, normal);
      }
    #endif

    // ============================================================
    // æ­¥é©Ÿ 7: æœ€çµ‚è™•ç† (åŸæ­¥é©Ÿ 6)
    // ============================================================
    finalColor = clamp(finalColor, 0.0, 1.0);
    finalColor.a = mainColor.a;

    #if USE_VERTEX_COLOR
      finalColor.rgb *= SRGBToLinear(v_color.rgb);
      finalColor.a *= v_color.a;
    #endif

    #if USE_ALPHA_TEST
      if (finalColor.ALPHA_TEST_CHANNEL < alphaThreshold) discard;
    #endif

    return CCFragOutput(finalColor);
  }
}%